"""
This security layer inadequately handles the undo functionality

Note:
	This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
	Also you need to give it an application to run.
	python repy.py restrictions.default encasementlib.r2py reference_monitor_sl9052.r2py application.r2py

"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"

class LPFile():
	def __init__(self, filename, create):
		# globals
		mycontext['debug'] = False
		self.LPfile = openfile(filename, create)
		self.pending_data = None
		self.pending_offset = None
		self.closed = False
		self.lock = createlock()
		self.file_size = len(self.readat(None, 0))

	def readat(self, bytes, offset):
		# Read from the file using the sandbox's readat...
		return self.LPfile.readat(bytes, offset)

	def writeat(self, data, offset):
		self.lock.acquire(True)

		try: 
			# Raise error when the offset is out of bounds
			if offset < 0:
				raise RepyArgumentError("Negative read offset invalid!")
			# Check for data type
			if type(data) is not str:
				raise RepyArgumentError("Argument must only be a string!")
			# Check if closed
			if self.closed:
				raise FileClosedError("File is already closed!")
			# Raise error when the offset is out of bounds
			if offset > self.file_size:
				raise SeekPastEndOfFileError("Seek offset extends past EOF!")

			# The changes from the previous writeat have not been applied yet
			if self.pending_data is not None and self.pending_offset is not None:
				# Apply the pending changes before executing the new writeat
				self.LPfile.writeat(self.pending_data, self.pending_offset)

			# Update pending data and offset
			self.pending_data = data
			self.pending_offset = offset

			# Calculate the new file size if the write operation extends beyond the current file size
			if offset + len(data) > self.file_size:
				self.file_size = offset + len(data)

		finally:
			self.lock.release()

	def undo(self):
		self.lock.acquire(True)

		try:
			if self.closed:
				return

			if self.pending_data is not None and self.pending_offset is not None:
				# Undo the last writeat operation.
				self.pending_data = None
				self.pending_offset = None

				# Update the filesize
				self.file_size = len(self.readat(None, 0))

		finally:
			self.lock.release()

	def close(self):
		self.lock.acquire(True)

		try:
			if self.closed:
				raise FileClosedError("File is already closed!")

			if self.pending_data is not None and self.pending_offset is not None:
				self.LPfile.writeat(self.pending_data, self.pending_offset)

			# Reset all variables
			self.LPfile.close()
			self.pending_data = None
			self.pending_offset = None
			self.closed = True
			self.file_size = 0;

		finally:
			self.lock.release()

def LPopenfile(filename, create):
	return LPFile(filename, create)

# The code here sets up type checking and variable hiding for you.
# You should not need to change anything below here.
sec_file_def = {
	"obj-type": LPFile,
	"name": "LPFile",
	"writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": LPFile.writeat},
	"readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": LPFile.readat},
	"undo": {"type": "func", "args": None, "exceptions": None, "return": type(None), "target": LPFile.undo},
	"close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": LPFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
	TYPE: OBJC,
	ARGS: (str, bool),
	EXCP: Exception,
	RETURN: sec_file_def,
	TARGET: LPopenfile
}

# Execute the user code
secure_dispatch_module()